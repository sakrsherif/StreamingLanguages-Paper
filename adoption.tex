\subsection{Adoption}\label{sec:adoption} % Martin

Stream processing languages have an adoption problem. As
Section~\ref{sec:languages} illustrates, there are several different
styles of streaming languages, each comprising several different
streaming languages. But there is no one streaming language that has
been broadly adopted. Out of the different styles of streaming languages,
perhaps the one receiving the most attention from large technology
companies is big-data streaming, including offerings by
Google~\cite{akidau_et_al_2013}, Microsoft~\cite{ali_et_al_2009},
IBM~\cite{hirzel_schneider_gedik_2017}, and
Twitter~\cite{toshniwal_et_al_2014}. However, they all differ, and
most of them are not stand-alone languages but libraries embedded in a
host language. That makes them hard to define in isolation and limits
their adoption beyond their host language.  One of the most-used languages
mentioned in this survey is Scade~\cite{scade_2017}, but it is designed for
embedded systems and not big-data streaming. Thus, getting broad
adoption for a big-data streaming language remains an open challenge.

Solving the adoption problem for stream processing languages would
yield many benefits. If students knew which stream processing language
will give them the best job prospects, they would invest in developing
those skills. And if employers knew for which stream processing
language there is a strong and sustainable hiring pipeline, they could
reduce their risk in depending on that language.  From the perspective
of streaming researchers and vendors, increased adoption of streaming
languages might lead to increased attention to streaming research and
streaming products, respectively. If most systems adopted more-or-less
the same language, it would become easier to benchmark them against
each other. Other popular programming languages, such as SQL, Java,
and JavaScript, have benefited when companies competed against each
other to provide better implementations of the language.  Of course,
there is also a downside. Focusing on a single language would reduce
the diversity of the eco-system, transforming innovation and
competition from being broad to being deep. But overall, if the
problem of streaming language adoption were solved, we would expect
streaming systems to become more robust and faster.

If streaming language adoption were easy, it would have happened by
now. Instead, despite the massive recent interest in big-data
streaming, no single streaming language has reached broad adoption.
This indicates that streaming language adoption is a difficult
problem. Perhaps one reason is that, in the pursuit of
interoperability and expediency, most big-data streaming languages are
not stand-alone but embedded in a host language. While being embedded
gives a short-term boost to language development, the entanglement
with a host language makes it hard to offer stable and clear
semantics. And, if the history of databases is any guide, such stable
and clear semantics are useful for agreeing on and consistently
implementing a standard. Part of the reason that the relational model
for databases displaced its disparate predecessors is its strong
mathematical foundation. However, when it comes to streaming
languages, there is not even a consensus on what are the most
important features to include. For instance, both the veracity
challenge and the variety challenge discussed previously have given
rise to many feature ideas that have yet to make it into the
main-stream. Finally, language adoption is driven not just by the
technical merits of the language itself, but also by external factors,
such as industry support, or implementations that are not just
open-source but have open governance.

The streaming language adoption challenge can be broken down into the
following metrics $\mathbf{C_7}$--$\mathbf{C_9}$:
\begin{itemize}
  \item[$\mathbf{C_7}$] Widely-used implementation of one language.
  \item[$\mathbf{C_8}$] Standard or at least standard proposal.
  \item[$\mathbf{C_9}$] Multiple implementations of same language.
\end{itemize}

Adoption is hard for any programming language, but we believe it is
particularly hard for a streaming language. While streaming in general
is not new~\cite{stephens_1997}, big-data streaming is a relatively
recent phenomenon. And big-data streaming, in turn, is driven by
several ongoing industry trends, including the internet of things
(IoT), cloud computing (where large-scale elastic compute resources
can be rented on short notice), and artificial intelligence
(AI). Since the trends of IoT, cloud, and AI are themselves all
actively shifting, they provide an unstable environment for streaming
languages to grow up in. Furthermore, for some of these trends, the
innovation takes place mostly in a setting where data is assumed to be
at rest, as opposed to streaming, where data is in motion. For
instance, most AI algorithms work over a fixed training data set, and
for most of them, additional research is necessary to make them work
well online. Besides these recent industry trends, the stream
processing research community itself harks back to origins in
different established disciplines.  Since people come to streaming
research from different perspectives, they sometimes do not even know
about each other's work, inhibiting adoption. This survey aims to
mitigate that problem.
