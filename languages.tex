\section{Stream Processing Languages}\label{sec:languages}

\begin{alltt}TODO\scriptsize ~2.8 pages total
- this section will have ~0.3 pages about each language, and
  each of these snippets will be structured around questions:
  why-who-when-what-where-whence
  (see CQL for an example, but the others will be similar!)
- before the snippets on each of the languages, we will briefly
  introduce and explain these questions, as follows:
  - why: objective, audience, domain
  - who: inventors, supporters
  - when: first release / first paper
  - what: key idea, data model, type system, code example
  - where: being developed or offered today, license
  - whence: influenced-by and influences
- descriptions of individual languages
  - relational / CQL \cite{arasu_babu_widom_2006}   \textcolor{red}{Sherif}
    - why: precise semantics \cite{arasu_widom_2004}, example app linear-road \cite{arasu_et_al_2004}
    - who: Arasu/Widom at Stanford
    - when: 2004
    - what: algebra of R2R (relational), S2R (windows), R2S (I/R/D);
      data model relational; type system \cite{soule_et_al_2016}; example Figure~\ref{fig:cql}
    - where: Stanford STREAM no longer active
    - whence: influenced-by TelegraphCQ \cite{chandrasekaran_et_al_2003},
      influences StreamInsight \cite{ali_et_al_2009} and many others
  - synchronous dataflow / Lustre \cite{caspi_et_al_1987} \textcolor{red}{Guillaume}
  - big-data streaming / SPL \cite{hirzel_schneider_gedik_2017} \textcolor{red}{Martin, Emanuele}
  - CEP (complex event processing) / MATCH-RECOGNIZE \cite{zemke_et_al_2007} \cite{hirzel_2012} \textcolor{red}{Angela}
  - XML / NiagaraCQ \cite{chen_et_al_2000}, YFilter \cite{diao_et_al_2002} \textcolor{red}{Sherif}
  - RDF / C-SPARQL \cite{barbieri_et_al_2009} \textcolor{red}{Emanuele, Akrivi}
  - stream reasoning \textcolor{red}{Emanuele}
  - reactive spreadsheets / ActiveSheets \cite{vaziri_et_al_2014} \textcolor{red}{Martin}
  - controlled natural language / META \cite{arnold_et_al_2016} \textcolor{red}{Martin}
- close with summary/comparison table
  - perhaps according to performance/generality/productivity
\end{alltt}

\begin{figure}
\begin{lstlisting}
SELECT IStream(Max(len) AS mxl,
                 MaxCount(len) AS num,
                 ArgMax(len, caller) as who)
FROM Calls[Range 24 Hours Slide 1 Minute]
\end{lstlisting}
\vspace*{-4mm}
\caption{\label{fig:cql}CQL code example.}
\end{figure}

In 2004, Arasu et al.\ at Stanford introduced CQL (for Continuous
Query Language)~\cite{arasu_widom_2004}. CQL has been designed as an
SQL-based declarative language for implementing continuous queries
against streams of data. The design was influenced by the language of
the TelegraphCQ system that proposed a declarative language with a
particular focus on expressive windowing
constructs~\cite{chandrasekaran_et_al_2003}. The semantics of CQL are
based on two data types: \emph{streams} and \emph{relations}. It
supports three classes of operators over these types. First,
\emph{stream-to-relation} operators, which produce a relation from a
stream.  The design of these operators is based on the concept of a
\emph{window} over a stream, which, at any point of time, contains a
historical snapshot of a recent portion of the stream. CQL includes
time-based and tuple-based windows, both with optional
partitioning. Second, \emph{relation-to-relation} operators, which
produce a relation from other relations. These operators are derived
from traditional relational algebra and are expressed using standard
SQL. Third, \emph{relation-to-stream} operators, which produce a
stream from a relation. CQL supports three operators of this class:
IStream, DStream, and RStream (to capture inserts, deletes, or the
relation).  Figure~\ref{fig:cql} illustrates a CQL code example that
uses a time-sliding window (per minute within the last 24 hours) over
phone calls to return the maximum phone call length along with its
count and caller information. CQL has influenced the design of many
systems such as Microsoft StreamInsight~\cite{ali_et_al_2009}.

\begin{figure}
\begin{lstlisting}
CREATE CQ
XML-QL query expression
DO action
{START start_time} 
{EVERY time_interval} 
{EXPIRE expiration_time}
\end{lstlisting}
\caption{\label{fig:Niagra}NiagaraCQ code example}
\end{figure}

Chen et al.\ introduced  \texttt{NiagaraCQ}~\cite{chen_et_al_2000} as a continuous query sub-system of the \texttt{Niagara}
Internet query engine\footnote{\url{http://research.cs.wisc.edu/niagara/}},  a distributed database system for querying distributed XML data sets which has been developed at University of Wisconsin and Oregon Graduate Institute~\cite{naughton2001niagara}. NiagaraCQ implements continuous query processing over multiple and distributed XML files by supporting incremental evaluation and considering only the changed portion of each updated XML file. It supports two types of continuous queries that differ on the criteria of triggering their execution:
1) \emph{Change-based}  queries: they are triggered as soon as new relevant data becomes available. 2) \emph{Timer-based}  queries: they are triggered only at time intervals specified by the submitting user. The query language of NiagaraCQ is based on the \texttt{XML-QL}\footnote{\url{https://www.w3.org/TR/1998/NOTE-xml-ql-19980819/}} query language~\cite{deutsch1999query}.
It provides a command language for creating continuous queries that follows the  form illustrated in Figure~\ref{fig:Niagra}. Using this command language, users can implement continuous queries that combines an ordinary XML-QL query with additional time information.
According to illustrated form, the query ($CQ$) will become effective at the defined $start\textunderscore time$. The
$time\textunderscore interval$ is used to indicate how often the query will be executed. A
query is classified as a timer-based if its $time\textunderscore interval$ is not zero; otherwise, it
is classified as a change-based. 
The defined continuous query ($CQ$) will be deactivated after its $expiration\textunderscore time$. The specified query action $Action$ will be triggered once the results of the XML-QL query expression is returned.  A key optimization mechanism used  in the NiagaraCQ system is grouping the execution of similar queries to minimize redundant work.  Similar optimization approach has been adopted by Diao et al.~\cite{diao_et_al_2002} in the implementation of  \texttt{YFilter}, a filtering engine for streaming XML documents based on the W3C standard XML query languages: \texttt{XPath}\footnote{\url{https://www.w3.org/TR/1999/REC-xpath-19991116/}} and \texttt{XQuery}\footnote{\url{https://www.w3.org/XML/Query/}}. The main idea of YFilter is to use Finite State Machines (FSM)  to represent and evaluate XML path expressions and to combine the execution multiple queries into a single Nondeterministic Finite Automaton (NFA). 
