\section{Stream Processing Languages}\label{sec:languages}

\begin{alltt}TODO\scriptsize ~2.8 pages total
- this section will have ~0.3 pages about each language, and
  each of these snippets will be structured around questions:
  why-who-when-what-where-whence
  (see CQL for an example, but the others will be similar!)
- before the snippets on each of the languages, we will briefly
  introduce and explain these questions, as follows:
  - why: objective, audience, domain
  - who: inventors, supporters
  - when: first release / first paper
  - what: key idea, data model, type system, code example
  - where: being developed or offered today, license
  - whence: influenced-by and influences
- descriptions of individual languages
\end{alltt}

\begin{figure}[!h]
\begin{lstlisting}
SELECT IStream(Max(len) AS mxl,
                 MaxCount(len) AS num,
                 ArgMax(len, caller) as who)
FROM Calls[Range 24 Hours Slide 1 Minute]
\end{lstlisting}
\vspace*{-4mm}
\caption{\label{fig:cql}CQL code example.}
\end{figure}

\textbf{Relational Streaming.}
In 2004, Arasu et al.\ at Stanford introduced CQL (for Continuous
Query Language)~\cite{arasu_widom_2004}. CQL has been designed as an
SQL-based declarative language for implementing continuous queries
against streams of data, such as the LinearRoad
benchmark~\cite{arasu_et_al_2004}. The design was influenced by the language of
the TelegraphCQ system that proposed a declarative language with a
particular focus on expressive windowing
constructs~\cite{chandrasekaran_et_al_2003}. The semantics of CQL are
based on two data types: \emph{streams} and \emph{relations}. It
supports three classes of operators over these types. First,
\emph{stream-to-relation} operators, which produce a relation from a
stream.  The design of these operators is based on the concept of a
\emph{window} over a stream, which, at any point of time, contains a
historical snapshot of a recent portion of the stream. CQL includes
time-based and tuple-based windows, both with optional
partitioning. Second, \emph{relation-to-relation} operators, which
produce a relation from other relations. These operators are derived
from traditional relational algebra and are expressed using standard
SQL. Third, \emph{relation-to-stream} operators, which produce a
stream from a relation. CQL supports three operators of this class:
IStream, DStream, and RStream (to capture inserts, deletes, or the
relation).  Figure~\ref{fig:cql} illustrates a CQL code example that
uses a time-sliding window (per minute within the last 24 hours) over
phone calls to return the maximum phone call length along with its
count and caller information. CQL has influenced the design of many
systems such as Microsoft StreamInsight~\cite{ali_et_al_2009}.


\begin{figure}[!h]
\begin{lstlisting}
node tracker (speed, limit: int) returns (t: int);
var x: bool; cpt: int when x;
let
  x = (speed > limit);
  cpt = counter((0, 1) when x);
  t = current(cpt);
tel
\end{lstlisting}
\caption{\label{fig:lustre} Lustre code example}
\end{figure}

\textbf{Synchronous Dataflow.}
Dataflow synchronous languages were introduced to ease the design of
real-time embedded systems. They allow to write a well-defined
deterministic specification of the system. It is then possible to
test, verify, and generate embedded code.
The first dataflow synchronous languages Lustre~\cite{lustre_1987}
(Caspi and Halbwachs) and Signal~\cite{signal_1991} (Le Guernic,
Benveniste, and Gautier) were proposed in France in the late 80s.
A dataflow synchronous program is a set of equations defining streams
of values. Time proceeds by discrete logical steps, and at each step,
the program computes the value of each stream depending on its inputs
and possibly previously computed values.
This approach is reminiscent of block diagrams, a popular notation to
describe control systems.
Figure~\ref{fig:lustre} presents a Lustre code example that tracks the
number of times the speed of a vehicle exceeds the speed limit. The
counter \lstinline{cpt} starts with~$0$ and is incremented by~$1$ each
time the current speed exceed the current limit (\lstinline{when x}).
The return value \lstinline{t} maintain the last computed value
of \lstinline{cpt} between two occurences of~\lstinline{x}
(\lstinline{current(cpt)}).
The dataflow synchronous approach has inspired
multiple languages: Lucid Synchrone~\cite{lucid_2006} combines the
dataflow synchronous approach with functional features \`a la ML,
StreamIt~\cite{streamit_2002} focuses on efficient processing of large
streaming applications, Z\'elus~\cite{zelus_2013} is a Lustre-like
language extended with ordinary differential equations to define
continuous-time dynamics. Lustre is also the backbone of the
industrial language and compiler Scade~\cite{scade_2017} routinely
used to program embedded controllers in many critical applications.

\textbf{Big-Data Streaming.}
\begin{alltt}TODO\scriptsize, ~0.3 pages, \textcolor{red}{Martin, Emanuele}
- SPL \cite{hirzel_schneider_gedik_2017}
\end{alltt}

\textbf{Complex Event Processing.}
\begin{alltt}TODO\scriptsize, ~0.3 pages, \textcolor{red}{Angela}
- MATCH-RECOGNIZE \cite{zemke_et_al_2007}, MatchRegex \cite{hirzel_2012}
\end{alltt}

\begin{figure}[!h]
\begin{lstlisting}
CREATE CQ
XML-QL query expression
DO action
{START start_time}
{EVERY time_interval}
{EXPIRE expiration_time}
\end{lstlisting}
\caption{\label{fig:Niagra}NiagaraCQ code example}
\end{figure}

\textbf{XML Streaming.}
Chen et al.\ introduced  \texttt{NiagaraCQ}~\cite{chen_et_al_2000} as a continuous query sub-system of the \texttt{Niagara}
Internet query engine\footnote{\url{http://research.cs.wisc.edu/niagara/}},  a distributed database system for querying distributed XML data sets which has been developed at University of Wisconsin and Oregon Graduate Institute~\cite{naughton2001niagara}. NiagaraCQ implements continuous query processing over multiple and distributed XML files by supporting incremental evaluation and considering only the changed portion of each updated XML file. It supports two types of continuous queries that differ on the criteria of triggering their execution:
1) \emph{Change-based}  queries: they are triggered as soon as new relevant data becomes available. 2) \emph{Timer-based}  queries: they are triggered only at time intervals specified by the submitting user. The query language of NiagaraCQ is based on the \texttt{XML-QL}\footnote{\url{https://www.w3.org/TR/1998/NOTE-xml-ql-19980819/}} query language~\cite{deutsch1999query}.
It provides a command language for creating continuous queries that follows the  form illustrated in Figure~\ref{fig:Niagra}. Using this command language, users can implement continuous queries that combines an ordinary XML-QL query with additional time information.
According to illustrated form, the query ($CQ$) will become effective at the defined $start\textunderscore time$. The
$time\textunderscore interval$ is used to indicate how often the query will be executed. A
query is classified as a timer-based if its $time\textunderscore interval$ is not zero; otherwise, it
is classified as a change-based.
The defined continuous query ($CQ$) will be deactivated after its $expiration\textunderscore time$. The specified query action $Action$ will be triggered once the results of the XML-QL query expression is returned.  A key optimization mechanism used  in the NiagaraCQ system is grouping the execution of similar queries to minimize redundant work.  Similar optimization approach has been adopted by Diao et al.~\cite{diao_et_al_2002} in the implementation of  \texttt{YFilter}, a filtering engine for streaming XML documents based on the W3C standard XML query languages: \texttt{XPath}\footnote{\url{https://www.w3.org/TR/1999/REC-xpath-19991116/}} and \texttt{XQuery}\footnote{\url{https://www.w3.org/XML/Query/}}. The main idea of YFilter is to use Finite State Machines (FSM)  to represent and evaluate XML path expressions and to combine the execution multiple queries into a single Nondeterministic Finite Automaton (NFA).

\textbf{RDF Streaming.}
\begin{alltt}TODO\scriptsize, ~0.3 pages, \textcolor{red}{Emanuele, Akrivi}
- C-SPARQL \cite{barbieri_et_al_2009}
- stream reasoning
\end{alltt}

\textbf{Reactive Programming.}
\begin{alltt}TODO\scriptsize, ~0.3 pages, \textcolor{red}{Martin}
- ActiveSheets \cite{vaziri_et_al_2014}
\end{alltt}

\textbf{Summary.}
\begin{alltt}TODO\scriptsize
- close with comparison table
- perhaps according to performance/generality/productivity
\end{alltt}
