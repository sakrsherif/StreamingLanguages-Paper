\subsection{Complex Event Processing}\label{sec:cep} % Angela

%/* Either from similar domain as CQL example:
%  alert when calls from locations over
%  10 miles apart within 60 seconds. */

\begin{figure}[!h]
\begin{lstlisting}
stream<Alert> Alerts = MatchRegex(Calls) {
  param
    partitionBy: caller;
    pattern    : ".+ tooFarTooFast";
    predicates : {
      tooFarTooFast =
            geoDist(First(loc), Last(loc)) >= 10.0
        && timeDist(First(ts), Last(ts)) <= 60.0; };
  output
    Alerts: who=caller, where=Last(loc), when=Last(ts);
}
\end{lstlisting}
\vspace*{-4mm}
\caption{\label{fig:cep}CEP example.}
\end{figure}

%/* Or from similar domain as Lustre example:
%   simple edge detector, each time a car's speed
%   increases over the speed limit, emit a tuple
%   with a count of 1. */
%stream<Edge> Edges = MatchRegex(CarUpdates) {
%  param  pattern    : "below above";
%         partitionBy: car;
%         predicates : { below = speed <= limit;
%                        above = speed > limit; };
%  output Edge: car=car, speed=Max(speed), count=1;
%}

Complex event processing (CEP) uses patterns over simple events to
detect higher-level, \emph{complex}, events that may comprise multiple
simple events.  CEP can be considered either as an alternative to
stream processing or as a special case of stream processing. The
latter consideration has led to the definition of CEP operators in
streaming languages. For example, the MatchRegex~\cite{hirzel_2012}
operator implements CEP in the library of the SPL
language~\cite{hirzel_schneider_gedik_2017} discussed in
Section~\ref{sec:big}. MatchRegex was introduced by Hirzel in~2012,
influenced by the \textsc{Match-Recognize} proposal for extending ANSI
SQL~\cite{zemke_et_al_2007}.  Compared to its SQL counterpart,
MatchRegex is simplified, syntactically concise, and easy to deploy as
a library operator. MatchRegex is implemented via code generation and
translates to an automaton for space- and time-efficient incremental
computation of aggregates. But it does not support other
functionalities beyond pattern matching, such as joins and reporting
tasks. Figure~\ref{fig:cep} shows an example for detecting a complex
event when simple phone-call events occur over 10~miles apart within
60~seconds. Line~4 defines the regular expression, where the period
(\lstinline{.}) matches any simple event; the plus (\lstinline{+})
indicates at-least-once repetition; and \lstinline{tooFarTooFast} is a
simple event defined via a predicate in \mbox{Lines 6--8}. The
\lstinline{First} and \lstinline{Last} functions reference
corresponding simple events in the overall match: in this case, the
start of the \lstinline{.+} and the simple event matched by
\lstinline{tooFarTooFast}.

We now turn to discuss two close predecessors of MatchRegex, namely the MATCH-RECOGNIZE~\cite{zemke_et_al_2007} clause of SQL and 
SASE~\cite{WuDR06}. The former has been introduced in order to capture pattern recognition in rows of a table. Patterns are described by a regular 
expression included in the PATTERN argument of the MATCH-RECOGNIZE clause and represented by variables. For instance, in our example of Figure~\ref{fig:cep}, the PATTERN argument contains a group variable given by $A+$ due to the presence of the Kleene-plus quantifier (where $A$ is defined AS
LAST(G.Loc) - FIRST(G.Loc) >= 10.0
        AND Last(T.ts) - FIRST(T.ts) <= 60.0 with G and T indicating the geodistance and timestamp relations). The clause permits to specify the output as a singleton (ONE ROW PER MATCH, also the default) or as a set of rows (ALL ROWS PER MATCH). The first option makes visible the columns specified in   the partition
columns, order by columns and columns defined in the MEASURES clause. For ALL
ROWS PER MATCH the visible columns include also all columns of the initial tables even though they are not used in the previous fields.
Since MATCH-RECOGNIZE is embedded in SQL, join conditions can be readily specified.

With the advent of Big Data, handling higher volumes of streaming data and being capable of accommodating larger windows become imperative. To address these two challenges, the SASE event system proposes to execute complex event queries on real-time streams. 
Figure~\ref{fig:SASE} shows the high-level syntax of the language, where the first clause EVENT specifies the types of events that need to be captured, while the second clause WHERE allows to filter those events by imposing suitable predicates applied to the events attributes and the third clause WITHIN indicates a time period in a sliding window over the input stream.  The first clause also allows to specify a sequence of types of events or their non occurrence 
via the special symbol $!$. However, it is not permitted to specify complex patterns under the form of regular expressions (thus with Kleene-star or Kleene-plus operator) and aggregates. Thus, the above example in Figure~\ref{fig:cep} is not expressible in SASE. The idea behind SASE is to have at disposal 
a self-contained language which can be translated to suitable algebraic query expressions. 

\begin{figure}[!h]
\begin{lstlisting}
EVENT ~\textit{event\_pattern}~
[WHERE ~\textit{qualification}~]
[WITHIN ~\textit{window}~]
\end{lstlisting}
\vspace*{-4mm}
\caption{\label{fig:SASE}Syntax of the Sase CEP Language.}
\end{figure}
