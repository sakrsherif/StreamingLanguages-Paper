\section{Principles}\label{sec:principles}

The previous section described concrete stream processing languages
belonging to several language families. This section takes a
cross-cutting view and explores concepts that many of these languages
have in common by identifying the language design principles behind
the concepts.  Explicitly articulating principles demystifies the art
of language design, turning it into more of a science. We categorize
language design principles according to the three requirements from
Section~\ref{sec:introduction}, namely performance, generality, and
productivity.

The performance requirement is addressed by the following streaming
language design principles:
\begin{description}
  \item[Windowing principle:] Windows turn streaming data into static
    data suitable for optimized static computation.  For instance, in
    CQL, windows produce relations suitable for classic relational
    algebra~\cite{arasu_babu_widom_2006}, optimizable via relational
    rewrite rules (see Section~\ref{sec:sql}).
  \item[Partitioning principle:] Key-based partitions enable
    independent computation over disjoint state, thus simplifying data
    parallelism. For instance, MatchRegex performs complex event
    processing separately by partition~\cite{hirzel_2012} (see Line~3
    of Figure~\ref{fig:cep}).
  \item[Stream graph principle:] Streaming applications are graphs of
    operators that communicate almost exclusively via streams, making
    them easy to place on different cores or machines. For instance,
    SPL programs are explicit stream
    graphs~\cite{hirzel_schneider_gedik_2017} (see
    Figure~\ref{fig:spl}).
  \item[Restriction principle:] The schedules and communication rates
    in a streaming application are restricted for both performance and
    safety. For instance, Lustre programs can only have causal cycles
    that have explicit delays~\cite{lustre_1987} (see
    Section~\ref{sec:sdf}).
\end{description}

\begin{alltt}TODO\scriptsize
- generality
  - keep concepts orthogonal (independent, irredundant, composable, regular)
    - e.g., CQL, relational algebra works as expected
  - keep the core language slim by enabling extensions in the library
    - e.g., SPL, relational operators are not built-in but in library
  - reactivity as a pun
    - e.g., ActiveSheets, basic formulas lifted from static to live data
  - unify similar concept into a single, more general concept
    - e.g., SPL, param clause can take thunk expressions
- productivity
  - keep syntax of non-streaming features similar to non-streaming languages
    - e.g., CQL, select-from-where
  - reserve the most concise syntax for the most common tasks
    - e.g., MatchRegex, sequencing in regex by juxtaposition
  - keep the syntax of definitions/declarations, and uses similar
    - e.g., RSP-QL, patterns resemble data \{ ?m1 :topic ?topic \}
  - follow the code direction with both scope and control dominance
    - e.g., Lustre; on the other hand, CQL is a counter-example!
- closing paragraph / transition
  - comparison table (one row per language/category,
    one column each for performance, generality, and productivity)
  - now that we have seen concepts that are present in most streaming
    languages, the next section will explore concepts that are missing
    or underdeveloped
\end{alltt}
