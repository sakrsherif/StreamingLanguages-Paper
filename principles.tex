\section{Principles}\label{sec:principles}

\begin{alltt}TODO\scriptsize
- introductory paragraph
  - now that we have seen concrete languages, we will take a
    cross-cutting view and explore recurring tricks and concepts
  - in fact, we will go one step further and identify the
    principles behind the concepts
  - explicitly articulating principles helps demystify the
    art of language design and turn it into more of a science
  - we can categorize the principles according to requirements
    from intro: performance, generality, productivity
- for each principle:
  - name
  - tagline
  - motivation
  - concrete example from one of the figures in Section~\ref{sec:languages}
- performance
  - windows define static view
    - e.g., CQL, can then apply static relational algebra
  - favor restrictions that simultaneously improve performance and safety
    - e.g., Lustre, causal cycles require delay
  - graph of operators
    - e.g., SPL, stream<T> S = O(S) \{..\}
  - partition independence
    - e.g., MatchRegex
- generality
  - keep concepts orthogonal (independent, irredundant, composable, regular)
    - e.g., CQL, relational algebra works as expected
  - keep the core language slim by enabling extensions in the library
    - e.g., SPL, relational operators are not built-in but in library
  - reactivity as a pun
    - e.g., ActiveSheets, basic formulas lifted from static to live data
  - unify similar concept into a single, more general concept
    - e.g., SPL, param clause can take thunk expressions
- productivity
  - keep syntax of non-streaming features similar to non-streaming languages
    - e.g., CQL, select-from-where
  - reserve the most concise syntax for the most common tasks
    - e.g., MatchRegex, sequencing in regex by juxtaposition
  - keep the syntax of definitions/declarations, and uses similar
    - e.g., RSP-QL, patterns resemble data \{ ?m1 :topic ?topic \}
  - follow the code direction with both scope and control dominance
    - e.g., Lustre; on the other hand, CQL is a counter-example!
- closing paragraph / transition
  - comparison table (one row per language/category,
    one column each for performance, generality, and productivity)
  - now that we have seen concepts that are present in most streaming
    languages, the next section will explore concepts that are missing
    or underdeveloped
\end{alltt}
