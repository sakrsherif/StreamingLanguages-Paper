\subsection{XML Streaming}\label{sec:xml} % Sherif

In 2002, Diao et al.~\cite{diao_et_al_2002} presented %\cite{diao2003high}
\textsf{YFilter}, which implemented continuous queries over XML
streaming data using a subset of the XPath
language~\cite{clark_derose_1999}. YFilter applied a multi-query
optimization that used a single finite state machine to represent and
evaluate several XPath expressions. In particular, YFilter exploited
commonalities among path queries by merging the common prefixes of
the paths so that they were processed at most once. This shared
processing improved performance significantly by
avoiding redundant processing for duplicate path expressions.  \iffalse To
handle value-based predicates that address contents of elements,
YFilter applied two alternative approa\-ches. The first approach
evaluates the predicates once the addressed elements are read from a
document, while the second approach postpones predicate evaluation
until the corresponding path expression has been entirely matched.\fi

Before YFilter, which processed streams of XML documents, came
\textsf{NiagaraCQ}, which processed update streams to existing XML
documents~\cite{chen_et_al_2000}, borrowing syntax from
XML-QL~\cite{deutsch1999query}.  NiagaraCQ supported incremental
evaluation to consider only the changed portion of each updated XML
file. It supported two kinds of continuous queries:
\emph{change-based} queries, which trigger as soon as new relevant
data becomes available, and \emph{timer-based} queries, which trigger
only at specified time intervals. \textsf{XSQ} is an XPath-based
language for not just filtering but transforming streams of XML
documents~\cite{peng_chawathe_2003}. And \textsf{XMLParse} is an
operator for XML stream transformation in a big-data streaming
language~\cite{mendell_et_al_2012}.
