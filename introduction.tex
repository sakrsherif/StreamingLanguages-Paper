\section{Introduction}\label{sec:introduction}

We have entered the big-data era: the world is awash with data, and
more data is being produced every minute of every day. Data analytics
solutions must contend with data being big both in the static-data sense of
an ocean of many bytes and in the streaming sense of a firehose of
many bytes-per-second. In fact, driven by the realization that static
data is merely a snapshot of parts of a data stream, the data technology
industry is focusing increasingly on data-in-motion. Analyzing
the stream instead of the ocean yields more timely insights and saves
storage resources.

Stream processing languages facilitate the development of stream
processing applications. Streaming languages make common tasks easy to
write and make code more readable and maintainable, and their
compilers catch programming mistakes and apply optimizing code
transformations. The landscape of streaming languages is diverse and
lacks broadly accepted standards.  Stephens~\cite{stephens_1997} and
Johnston et al.~\cite{johnston_hanna_millar_2004} published surveys on
stream processing languages in 1997 and 2004. Much has happened since
then, from database-inspired streaming languages to the rise of big
data and beyond. Our survey continues where prior surveys left off,
focusing on streaming languages in the big-data era.

A \emph{stream} is a sequence of data items, and the length of a
stream is conceptually infinite, in the sense that waiting for it to
end is ill-defined. A streaming application is a computer program that
consumes and produces streams. A stream processing language is a
domain-specific language designed for expressing streaming
applications. The goal of a stream processing language is to strike a
balance between the three requirements of performance, generality, and
productivity. Performance is about handling high-throughput input
streams with low-latency output streams. Generality is about making it
possible to handle a variety of processing needs and data formats. And
productivity is about enabling developers to write correct code
quickly.

Traditionally, programming languages have been characterized by their
paradigm, including imperative, functional, declarative,
object-oriented, etc. However, for streaming languages, the paradigm
is not the most important characteristic; most streaming languages are
more-or-less declarative. What is more important is the underlying
data model (e.g., relational, XML, RDF), execution model (e.g.,
synchronous, big-data), and targeted domain and user base (e.g., event
detection, end-users).  Section~\ref{sec:languages} surveys languages
based on these characteristics.

Section~\ref{sec:principles} generalizes from individual languages to
extract recurring concepts and principles. Section~\ref{sec:whatsnext}
takes the opposite point of view: instead of looking at what most
streaming languages have in common, it explores what most streaming
languages lack and formulates open challenges. Finally,
Section~\ref{sec:conclusion} concludes. Given how many stream
processing languages have been invented recently, it appears likely
that more will be invented soon. We hope this survey will help
inventors of new stream processing languages do a better job by giving
them a good understanding of the state of the art.
