\section{Introduction}\label{sec:introduction}

We have entered the big-data era: the world is awash with data, and
more data is being produced every minute of every day. Data analytics
solutions must contend with data being big both in the static-data sense of
an ocean of many bytes and in the streaming sense of a firehose of
many bytes-per-second. In fact, driven by the realization that static
data is merely a snapshot of parts of a data stream, the data technology
industry is focusing increasingly on data-in-motion. Analyzing
the stream instead of the ocean yields more timely insights and saves
storage resources.

Stream processing languages facilitate the development of stream
processing applications. Streaming languages make common tasks easy to
write, reduce clutter to make code more readable and maintainable, and
their compilers catch programming mistakes and apply optimizing code
transformations. Stephens published a survey on stream processing
languages back in~1997. Much has happened since then, from new
database-inspired streaming languages to the rise of big data and
beyond. Our survey continues where Stephens left off, giving an
overview of streaming languages in the big-data era.

\begin{alltt}TODO\scriptsize ~1.5 pages
- motivation
  - diversity of languages, lack of standard
  - lack of a recent survey \cite{stephens_1997} \cite{johnston_hanna_millar_2004}
- background / definitions
  - stream, streaming application, DSL, stream processing language
  - requirements: performance, generality, productivity
  - most streaming languages are declarative, so the traditional
    paradigm categories imperative or functional don't apply
- common ideas/principles/tropes:
  - streaming specific
    - keep syntax of non-streaming featurs similar to non-streaming languages
    - to-and-from static
    - reactivity as a pun
    - graph of operators
  - general
    - keep concepts orthogonal (independent, composable, and regular)
    - unify similar concept into a single, more general concept
    - reserve the most concise syntax for the most common tasks
    - keep the core language slim by enabling extensions in the library
    - keep the syntax of definitions, declarations, and uses similar
    - follow the code direction with both scope and control dominance
    - favor restrictions that simultaneously improve performance and safety
- roadmap for rest of paper
- take-home message: democratization of streaming
\end{alltt}
